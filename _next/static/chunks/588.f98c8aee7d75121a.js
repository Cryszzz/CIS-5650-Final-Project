(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[588],{588:function(e,t,a){"use strict";a.r(t),a.d(t,{default:function(){return main}});var n=a(6416),r=a(5893),i=a(9008),o=a.n(i),s=a(1163),l=a(7294),u=a(4131),c=a.n(u);a(6876);let SampleLayout=e=>{let t=(0,l.useRef)(null),n=(0,l.useMemo)(()=>e.sources.map(e=>{let{name:t,contents:n}=e;return{name:t,...function(e){let t;let n=null;{n=document.createElement("div");let e=a(4631);t=e(n,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(a){return(0,r.jsx)("div",{...a,children:(0,r.jsx)("div",{ref:a=>{n&&a&&(a.appendChild(n),t.setOption("value",e))}})})}}}(n)}}),e.sources),i=(0,l.useRef)(null),u=(0,l.useMemo)(()=>{if(e.gui){let e=a(4376),t=new e.GUI({autoPlace:!1});return t.domElement.style.position="relative",t.domElement.style.zIndex="1000",t}},[]),m=(0,l.useRef)(null),f=(0,l.useMemo)(()=>{if(e.stats){let e=a(2792);return new e}},[]),d=(0,s.useRouter)(),p=d.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[g,h]=(0,l.useState)(null),[x,P]=(0,l.useState)(null);return(0,l.useEffect)(()=>{if(p?P(p[1]):P(n[0].name),u&&i.current)for(i.current.appendChild(u.domElement);u.__controllers.length>0;)u.__controllers[0].remove();f&&m.current&&(f.dom.style.position="absolute",f.showPanel(1),m.current.appendChild(f.dom));let a={active:!0};try{let n=t.current;if(!n)throw Error("The canvas is not available");let r=e.init({canvas:n,pageState:a,gui:u,stats:f});r instanceof Promise&&r.catch(e=>{console.error(e),h(e)})}catch(e){console.error(e),h(e)}return()=>{a.active=!1}},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(o(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description}),(0,r.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,r.jsxs)("div",{className:c().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",left:10},ref:m}),(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:i}),(0,r.jsx)("canvas",{ref:t})]})]})},makeSample=e=>(0,r.jsx)(SampleLayout,{...e});var m="struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n@binding(1) @group(0) var mySampler: sampler;\n@binding(2) @group(0) var myTexture: texture_cube<f32>;\n\nconst skybox_size=3000.0;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vs_main(\n  @location(0) position : vec4<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  var cam=uniforms.modelViewProjectionMatrix;\n  output.Position =  uniforms.modelViewProjectionMatrix*vec4<f32>(position.xyz*skybox_size,1.0);\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n\n@fragment\nfn fs_main(\n  @location(0) fragUV: vec2<f32>,\n  @location(1) fragPosition: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var cubemapVec = fragPosition.xyz - vec3(0.5);\n  var color=textureSample(myTexture, mySampler, cubemapVec);\n  return color;\n}";let f=new Float32Array([1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,1,0,1,-1,-1,1,1,0,0,1,0,0,1,-1,1,1,1,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,-1,1,1,1,0,1,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,1,-1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,-1,-1,1,1,0,0,1,1,0,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,-1,1,-1,1,0,1,0,1,0,0,-1,1,1,1,0,1,1,1,0,1,1,1,-1,1,1,1,0,1,1,0,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,-1,1,-1,1,0,1,0,1,1,0,-1,-1,-1,1,0,0,0,1,0,0,-1,-1,1,1,0,0,1,1,0,1,-1,1,-1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,0,-1,-1,1,1,0,0,1,1,1,0,1,-1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,-1,-1,1,1,0,0,1,0,1,-1,-1,-1,1,0,0,0,1,1,1,-1,1,-1,1,0,1,0,1,1,0,1,1,-1,1,1,1,0,1,0,0,1,-1,-1,1,1,0,0,1,0,1,-1,1,-1,1,0,1,0,1,1,0]);async function createSkyboxPipeline(e,t){return e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:m}),entryPoint:"vs_main",buffers:[{arrayStride:40,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:32,format:"float32x2"}]}]},fragment:{module:e.createShaderModule({code:m}),entryPoint:"fs_main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}})}async function loadCubemapTexture(e){var t;let a=["../assets/img/cubemap/sky2px.png","../assets/img/cubemap/sky2nx.png","../assets/img/cubemap/sky2py.png","../assets/img/cubemap/sky2ny.png","../assets/img/cubemap/sky2pz.png","../assets/img/cubemap/sky2nz.png"].map(async e=>{let t=await fetch(e);return createImageBitmap(await t.blob())}),n=await Promise.all(a);t=e.createTexture({dimension:"2d",size:[n[0].width,n[0].height,6],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let a=0;a<n.length;a++){let r=n[a];e.queue.copyExternalImageToTexture({source:r},{texture:t,origin:[0,0,a]},[r.width,r.height])}return t}async function renderSkybox(e,t,a,n,r,i,o){e.queue.writeBuffer(n,0,o.buffer,o.byteOffset,o.byteLength),i.setPipeline(t),i.setVertexBuffer(0,a),i.setBindGroup(0,r),i.draw(36)}var d='////////////////////////////////////////////////////////////////////////////////\n// Utilities\n////////////////////////////////////////////////////////////////////////////////\nvar<private> rand_seed : vec2<f32>;\nconst PI:f32=3.1416926535928;\nstruct SimulationCS {\n    MeasurementAltitude: f32,\n    TSnowA:f32,\n    TSnowB:f32,\n    TMeltA:f32,\n    TMeltB:f32,\n    k_e:f32,\n    k_m:f32,\n    meltFactor:f32,\n};\nconst SimulationCSConstants: SimulationCS = SimulationCS(0.0,0.0,2.0,-5.0,-2.0,0.2,4.0, 2.0);\n\nstruct ConfigurationCS {\n  posNormalizeFactor: f32,\n  posMax: f32,\n  colorMaxScaleFactor: f32,\n  areaScaleFactor: f32,\n  r_i_tScaleFactor: f32,\n  maxSWE: f32,\n  temperatureLapseNormalizeFactor: f32,\n  precipitationLapseNormalizeFactor: f32,\n};\n\nstruct WeatherData\n{\n	Temperature:f32,\n	Precipitation:f32,\n};\n\nstruct SimulationCSVar {\n    Timesteps: f32,\n    CurrentSimulationStep: f32,\n    HourOfDay: f32,\n    DayOfYear: f32,\n};\n\nconst SimulationCSVariables: SimulationCSVar = SimulationCSVar(0,0,12,35);\n\nfn init_rand(invocation_id : u32, seed : vec4<f32>) {\n  rand_seed = seed.xz;\n  rand_seed = fract(rand_seed * cos(35.456+f32(invocation_id) * seed.yw));\n  rand_seed = fract(rand_seed * cos(41.235+f32(invocation_id) * seed.xw));\n}\n\nfn rand() -> f32 {\n  rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);\n  rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);\n  return rand_seed.y;\n}\n\nfn Func2(L: f32, D: f32) -> f32 {\n    return acos(clamp(-tan(L) * tan(D), -1.0, 1.0));\n}\n\nfn Func3(V: f32, W: f32, X: f32, Y: f32, R1: f32, D: f32) -> f32 {\n    return R1 * (sin(D) * sin(W) * (X - Y) * (12.0 / PI) +\n                 cos(D) * cos(W) * (sin(X + V) - sin(Y + V)) * (12.0 / PI));\n}\n\nfn SolarRadiationIndex(I: f32, A: f32, L0: f32, J: f32) -> vec3<f32>{\n    var L1: f32 = acos(cos(I) * sin(L0) + sin(I) * cos(L0) * cos(A));\n    var D1: f32 = cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A);\n    var L2: f32 = atan(sin(I) * sin(A) / (cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A)));\n\n    var D: f32 = 0.007 - 0.4067 * cos((J + 10.0) * 0.0172);\n    var E: f32 = 1.0 - 0.0167 * cos((J - 3.0) * 0.0172);\n\n    let R0: f32 = 1.95;\n    var R1: f32 = 60.0 * R0 / (E * E);\n\n    var T: f32;\n    T = Func2(L1, D);\n    var T7: f32 = T - L2;\n    var T6: f32 = -T - L2;\n    T = Func2(L0, D);\n    var T1: f32 = T;\n    var T0: f32 = -T;\n    var T3: f32 = min(T7, T1);\n    var T2: f32 = max(T6, T0);\n\n    var T4: f32 = T2 * (12.0 / PI);\n    var T5: f32 = T3 * (12.0 / PI);\n\n    if (T3 < T2) {\n        T2 = 0.0;\n        T3 = 0.0;\n    }\n\n    T6 = T6 + PI * 2.0;\n\n    var R4: f32;\n    if (T6 < T1) {\n        var T8: f32 = T6;\n        var T9: f32 = T1;\n        R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);\n    } else {\n        T7 = T7 - PI * 2.0;\n\n        if (T7 > T0) {\n            var T8: f32 = T0;\n            var T9: f32 = T0;\n            R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);\n        } else {\n            R4 = Func3(L2, L1, T3, T2, R1, D);\n        }\n    }\n\n    var R3: f32 = Func3(0.0, L0, T1, T0, R1, D);\n\n    return vec3<f32>(T4,T5,R4 / R3);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Vertex shader\n////////////////////////////////////////////////////////////////////////////////\nstruct RenderParams {\n  modelViewProjectionMatrix : mat4x4<f32>,\n  campos : vec3<f32>,\n  fogStart:f32,\n  up : vec2<f32>,\n  fogEnd:f32,\n  heightMul : f32,\n  configurationCSVariables: ConfigurationCS,\n}\n@binding(0) @group(0) var<uniform> renderParams : RenderParams;\n@binding(1) @group(0) var fragtexture : texture_2d<f32>;\n@binding(2) @group(0) var origtexture : texture_2d<f32>;\n@binding(3) @group(0) var<uniform>  grid : vec2<f32>;\n@binding(4) @group(0) var heighttexture : texture_2d<f32>;\n@binding(5) @group(0) var<storage, read> maxSnow : array<u32>; \n\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : f32,\n  @location(2) uv: vec2<f32>, // -1..+1\n}\n\nstruct VertexOutput {\n  @location(0) position: vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>, // -1..+1\n\n  @builtin(position) Position : vec4<f32>,\n}\nconst heightMul:f32=0.01;\n@vertex\nfn vs_main(in : VertexInput,\n            @builtin(instance_index) instance: u32) -> VertexOutput {\n  var out : VertexOutput;\n  var textDim=vec2<i32>(textureDimensions(heighttexture));\n  let i = i32(instance);\n  let cell = vec2<i32>(i % (textDim.x - 1), i / (textDim.x - 1)); // should one be textDim.y - 1?\n  let p0:vec3<f32>=vec3<f32>(0.0,textureLoad(heighttexture,cell,0).x*renderParams.heightMul,0.0);\n  let p1:vec3<f32>=vec3<f32>(grid.x,textureLoad(heighttexture,vec2<i32>(cell.x+1,cell.y),0).x*renderParams.heightMul,0.0);\n  let p2:vec3<f32>=vec3<f32>(0.0,textureLoad(heighttexture,vec2<i32>(cell.x,cell.y+1),0).x*renderParams.heightMul,grid.y);\n  let p3:vec3<f32>=vec3<f32>(grid.x,textureLoad(heighttexture,vec2<i32>(cell.x+1,cell.y+1),0).x*renderParams.heightMul,grid.y);\n  var normal:vec3<f32>;\n  if(in.normal==0.0){\n    normal=normalize(cross(p2-p0,p3-p0));\n  }else{\n    normal=normalize(cross(p3-p0,p1-p0));\n  }\n  var coord:vec2<i32>=cell;\n  if(in.position.x > 0.0){\n    coord.x+=1;\n  }\n  if(in.position.z > 0.0){\n    coord.y+=1;\n  }\n\n  // Calculate displacement from snow\n  var fragDim=vec2<i32>(textureDimensions(fragtexture).xy);\n  var fragCoord : vec2<i32>=vec2<i32>(0,0);\n  fragCoord.x=i32(f32(coord.x) / f32(textDim.x) * f32(fragDim.x)); \n  fragCoord.y=i32(f32(coord.y) / f32(textDim.y) * f32(fragDim.y));  \n\n  var testcolor = textureLoad(fragtexture, fragCoord.xy, 0); \n  var testColorFirst = testcolor / renderParams.configurationCSVariables.posNormalizeFactor;\n  var testColorMax = clamp(testColorFirst * renderParams.configurationCSVariables.posMax * 10.0, vec4(0.0), vec4(renderParams.configurationCSVariables.posMax)); // change these values so that they can be multiplied by renderParams.heightMul\n  let cellOffset = vec2<f32>(cell-textDim/2)*grid;\n  var gridPos:vec2<f32> = (in.position.xz) * (grid/2.0) + cellOffset;\n  \n  var height:f32=textureLoad(heighttexture,coord,0).x;\n  out.Position = renderParams.modelViewProjectionMatrix * vec4<f32>(gridPos.x,(height + testColorMax.x)*renderParams.heightMul,gridPos.y, 1.0);\n  out.position=vec3<f32>(gridPos.x,(height + testColorMax.x)*renderParams.heightMul,gridPos.y);\n  out.normal =normal;\n  out.uv = vec2<f32>(f32(coord.x)/f32(textDim.x),f32(coord.y)/f32(textDim.y));\n  return out;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fragment shader\n////////////////////////////////////////////////////////////////////////////////\n\nconst lightPos : vec3<f32>= vec3<f32> (50.0, 100.0, -100.0);\nconst lightDir : vec3<f32>= vec3<f32> (1.0, -1.0, 0.0);\nconst ambientFactor = 0.4;\n/*\nThere are two texture bind to fragment shader\nfragtexture: the texture buffer that got from compute pipeline\norigtexture: the texture buffer that is the original texture\n\nThey varies in resolution, better to interpolate values for final result, but rn, change between these two to test whether we have correct computation.\n*/\nconst fogColor:vec3<f32> =vec3<f32>(0.5,0.5,0.5);\n\n@fragment\nfn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {\n  var test=renderParams.modelViewProjectionMatrix;\n  var textDim=vec2<i32>(textureDimensions(fragtexture).xy);\n  var textorigDim=vec2<i32>(textureDimensions(origtexture).xy);\n  var coord : vec2<i32>=vec2<i32>(0,0);\n\n  coord.x=i32(f32(textDim.x)*in.uv.x);\n  coord.y=i32(f32(textDim.y)*in.uv.y);\n  var testcolor = textureLoad(fragtexture, coord.xy, 0);\n\n  coord.x=i32(f32(textorigDim.x)*in.uv.x);\n  coord.y=i32(f32(textorigDim.y)*in.uv.y);\n  var origcolor = textureLoad(origtexture, coord.xy, 0);\n\n  var testColorMaxFirst = testcolor / (f32(maxSnow[0]) * renderParams.configurationCSVariables.colorMaxScaleFactor);\n  var testColorMaxScaled = select(testColorMaxFirst * 1.75, testColorMaxFirst * 0.75 + 0.20, testColorMaxFirst.x > 0.2); \n  var testcolorMax = clamp(testColorMaxScaled, vec4(0.0), vec4(1.0));\n  // var out_color = testcolorMax;\n  var out_color = (1.0-testcolorMax.x)*origcolor+testcolorMax.x*testcolorMax;\n\n  let lambertFactor = max(dot(normalize(-lightDir), in.normal), 0.0);\n  let lightingFactor = min(ambientFactor + lambertFactor, 1.0);\n  var color = vec4(lightingFactor*out_color.xyz,1.0);\n  var fogStart:f32 =renderParams.fogStart;\n  var fogEnd:f32 =renderParams.fogEnd;\n  let fogFactor:f32= clamp((fogEnd-length(renderParams.campos-in.position))/(fogEnd-fogStart),0.0,1.0);\n  let fogColorVec4: vec4<f32> =vec4<f32>(fogColor,1.0);\n  let colorWithFog:vec4<f32>=mix(fogColorVec4,color,fogFactor);\n  return colorWithFog;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Simulation Compute shader\n////////////////////////////////////////////////////////////////////////////////\n\nstruct SimulationParams {\n  simulationCSConstants: SimulationCS,\n  simulationCSVariables: SimulationCSVar,\n  configurationCSVariables: ConfigurationCS,\n  temperature: f32,\n  precipitation: f32,\n}\n\nstruct Cell { \n  Aspect: f32,\n  Inclination: f32,\n  Altitude: f32,\n  Latitude: f32,\n  Area: f32,\n  AreaXY: f32,\n  SnowWaterEquivalent: f32,\n  InterpolatedSWE: f32,\n  SnowAlbedo: f32,\n  DaysSinceLastSnowfall: f32,\n  Curvature: f32,\n  Padding:f32,\n}\nstruct Cells {\n  cells : array<Cell>,\n}\n\n@binding(0) @group(0) var<uniform> simParams : SimulationParams;\n@binding(1) @group(0) var<storage, read_write> data : Cells;\n@binding(2) @group(0) var texture : texture_2d<f32>;\n@binding(3) @group(0) var texture2 : texture_storage_2d<rgba32float, write>;\n@binding(4) @group(0) var<storage, read_write> maxSnowStorage : array<atomic<u32>>;\n\n@compute @workgroup_size(8,8)\nfn simulate(@builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n    \n    var textDim=vec2<i32>(textureDimensions(texture).xy);\n    var text2Dim=vec2<i32>(textureDimensions(texture2).xy);\n    var coord : vec2<i32>=vec2<i32>(global_invocation_id.xy);\n    var idx: u32= global_invocation_id.y*textureDimensions(texture2).x+global_invocation_id.x;\n\n    var loadcoord : vec2<i32>=vec2<i32>(0,0);\n    loadcoord.x=i32(coord.x*textDim.x/text2Dim.x);\n    loadcoord.y=i32(coord.y*textDim.y/text2Dim.y);\n    var color = textureLoad(texture, loadcoord, 0);\n    \n    // here is example of how to store color to texture, just modify color.xyz to change color\n    // if (coord)\n    // textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(color.xyz,1.0));\n\n    var celldata = data.cells[idx];\n    \n    var areaSquareMeters:f32 = celldata.AreaXY * simParams.configurationCSVariables.areaScaleFactor; // m^2 \n\n    var stationAltitudeOffset:f32 = celldata.Altitude - simParams.simulationCSConstants.MeasurementAltitude;\n    var temperatureLapse:f32 = - (0.5 * stationAltitudeOffset) / (simParams.configurationCSVariables.temperatureLapseNormalizeFactor);\n\n    var tAir:f32= simParams.temperature + temperatureLapse; // degree Celsius\n\n    var precipitationLapse:f32= 10.0 / 24.0 * stationAltitudeOffset / (simParams.configurationCSVariables.precipitationLapseNormalizeFactor);\n    var precipitation:f32 = simParams.precipitation;\n\n    celldata.DaysSinceLastSnowfall += 1.0 / 24.0;\n    \n    var output_color_debug = 0.1;\n\n      // Apply precipitation\n    if (precipitation > 0.0) {\n        precipitation += precipitationLapse;\n        celldata.DaysSinceLastSnowfall = 0.0;\n\n        // New snow/rainfall\n\n        if (tAir > simParams.simulationCSConstants.TSnowB) {\n            celldata.SnowAlbedo = 0.4; // New rain drops the albedo to 0.4\n        } else {\n            // Variable lapse rate as described in "A variable lapse rate snowline model for the Remarkables, Central Otago, New Zealand"\n            var snowRate:f32= max(0.0, 1.0 - (tAir - simParams.simulationCSConstants.TSnowA) / (simParams.simulationCSConstants.TSnowB - simParams.simulationCSConstants.TSnowA));\n\n            celldata.SnowWaterEquivalent += (precipitation * areaSquareMeters * snowRate); // l/m^2 * m^2 = l\n            celldata.SnowAlbedo = 0.8; // New snow sets the albedo to 0.8\n        }\n    }\n      \n      // Apply melt\n    if (celldata.SnowWaterEquivalent > 0.0) {\n        if (celldata.DaysSinceLastSnowfall >= 0.0) {\n            celldata.SnowAlbedo = 0.4 * (1.0 + exp(-simParams.simulationCSConstants.k_e * celldata.DaysSinceLastSnowfall));\n        }\n\n        // Temperature higher than melt threshold and cell contains snow\n        if (tAir > simParams.simulationCSConstants.TMeltA) {\n            var dayNormalization: f32 = 1.0 / 24.0; // day\n\n            // Radiation Index\n            var output: vec3<f32> = SolarRadiationIndex(celldata.Inclination,celldata.Aspect, celldata.Latitude, f32(simParams.simulationCSVariables.DayOfYear)); // 1\n\n            var r_i:f32=output.z;\n            var T4: f32=output.x;\n            var T5: f32=output.y;\n\n            // Diurnal approximation\n            var t: f32 = simParams.simulationCSVariables.HourOfDay;\n            var D: f32 = abs(T4) + abs(T5);\n            var r_i_t: f32 = max(abs(PI * r_i / 2.0 * sin(PI * f32(t) / D - abs(T4) / PI)) * simParams.configurationCSVariables.r_i_tScaleFactor, 0.0);\n            // Melt factor\n            var vegetationDensity: f32 = 0.0;\n            var k_v: f32 = exp(-4.0 * vegetationDensity); // 1\n            var c_m: f32 = simParams.simulationCSConstants.k_m * k_v * r_i_t * (1.0 - celldata.SnowAlbedo) * dayNormalization * areaSquareMeters; // l/m^2/C/day * day * m^2 = l/m^2 * 1/day * day * m^2 = l/C\n            var meltFactor: f32;\n            if(tAir < simParams.simulationCSConstants.TMeltB){\n                meltFactor=simParams.simulationCSConstants.meltFactor * (tAir - simParams.simulationCSConstants.TMeltA + 0.01) * (tAir - simParams.simulationCSConstants.TMeltA + 0.01) / (simParams.simulationCSConstants.TMeltB - simParams.simulationCSConstants.TMeltA);\n            } else {\n                meltFactor=simParams.simulationCSConstants.meltFactor * (tAir - simParams.simulationCSConstants.TMeltA);\n            }\n\n            // Added factor to speed up melting\n            var m: f32 = c_m * meltFactor; // l/C * C = l \n            output_color_debug = r_i ;\n            // Apply melt\n            celldata.SnowWaterEquivalent -= m;\n        }\n    }\n    celldata.SnowWaterEquivalent = clamp(celldata.SnowWaterEquivalent, 0, simParams.configurationCSVariables.maxSWE * celldata.AreaXY);\n    var slope = degrees(celldata.Inclination);\n    // var f = select((slope - (celldata.Altitude * (simParams.configurationCSVariables.areaScaleFactor / 100.0)) / 100.0) / 65.0 , 0, slope < 15.0);\n    var f = select(slope / 65.0 , 0, slope < 15.0);\n	  var a3 = 50.0;\n\n    // celldata.InterpolatedSWE = celldata.SnowWaterEquivalent * (1 - f);\n    celldata.InterpolatedSWE = clamp(celldata.SnowWaterEquivalent * (1.1 - f) * (1 + a3 * celldata.Curvature), 0.0, simParams.configurationCSVariables.maxSWE * celldata.AreaXY);\n    data.cells[idx] = celldata;\n    var output_color: f32=celldata.InterpolatedSWE;\n    atomicMax(&maxSnowStorage[0],u32(output_color));\n    \n    textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(output_color,output_color,output_color,1.0));\n}',p=a(8175);let lerp=(e,t,a)=>(1-a)*e+a*t;var g=[0,0];async function getHeightData(e){let t=await fetch(e),a=await (0,p.mK)(await t.blob()),n=await a.getImage(),r=await n.readRasters(),{ModelPixelScale:i,ModelTiepoint:o}=n.fileDirectory,[s,l,u]=i,[c,m,f,d,h,x]=o;l=-l;let P=[-d/s,1/s,0,-h/l,0,1/l],v=r[0],[S,w,y,b]=n.getBoundingBox(),T=lerp(w,b,Math.random()),C=lerp(S,y,Math.random()),[A,F]=function(e,t,a){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],round=e=>n?0|e:e;return[round(a[0]+a[1]*e+a[2]*t),round(a[3]+a[4]*e+a[5]*t)]}(C,T,P,!0),{width:M,0:_}=r,B=Math.floor(M/(y-S)*(b-w));g[0]=M,g[1]=B;let D=new Float32Array(v);return D}var h=a(7160),x=a(1437),P=[0,0];async function loadAndUseHeightData(e){let t=await getHeightData(e);return P[0]=g[0],P[1]=g[1],t}async function generateTerrainMesh(e,t,a){let n=await loadAndUseHeightData(e),r=P[0],i=P[1],o=Math.floor(r/t),s=Math.floor(i/t),l=[];for(let e=0;e<s*t;e+=t)for(let s=0;s<o*t;s+=t){let t=n[e*r+s];l.push([(s-r/2)*1,t/a,(e-i/2)*1])}return{positions:l,height:s,width:o}}async function getTerrainMesh(e,t,a){return await generateTerrainMesh(e,t,a)}let normalizeAngle360=e=>(e%=360)<0?e+2*Math.PI:e;async function getTerrainCells(e){return await generateTerrainCells(e)}function getCellIndex(e,t,a,n){let r=t*a+e;return r>=0&&r<a*n&&e<a&&e>0?r:-1}async function generateTerrainCells(e){let t=e.width,a=e.height,n=(t-1)*(a-1),r={P0:Array(n),P1:Array(n),P2:Array(n),P3:Array(n),Aspect:Array(n),Inclination:Array(n),Altitude:Array(n),Latitude:Array(n),Area:Array(n),AreaXZ:Array(n),SnowWaterEquivalent:Array(n),InterpolatedSWE:Array(n),SnowAlbedo:Array(n),DaysSinceLastSnowfall:Array(n),Curvature:Array(n),Size:(a-1)*(t-1),MinAltitude:1/0},i=0;for(let n=0;n<a-1;n++)for(let a=0;a<t-1;a++){let o=n*(t-1)+a;r.P0[o]=e.positions[n*t+a],r.P1[o]=e.positions[n*t+a+1],r.P2[o]=e.positions[(n+1)*t+a],r.P3[o]=e.positions[(n+1)*t+a+1];let s=h.al(r.P0[o][0],r.P0[o][1],r.P0[o][2]),l=h.al(r.P1[o][0],r.P1[o][1],r.P1[o][2]),u=h.al(r.P2[o][0],r.P2[o][1],r.P2[o][2]),c=h.al(r.P3[o][0],r.P3[o][1],r.P3[o][2]),m=h.kC(h.Ue(),h.$X(h.Ue(),l,s),h.$X(h.Ue(),u,s)),f=h.al((s[0]+l[0]+u[0]+c[0])/4,(s[1]+l[1]+u[1]+c[1])/4,(s[2]+l[2]+u[2]+c[2])/4);r.Altitude[o]=f[1],r.Altitude[o]<r.MinAltitude&&(r.MinAltitude=r.Altitude[o]);let d=h.$X(h.Ue(),s,u),p=h.$X(h.Ue(),l,u),g=x.al(d[0],d[2]),P=x.al(p[0],p[2]);r.Area[o]=Math.abs(h.Zh(h.kC(h.Ue(),d,d))/2+h.Zh(h.kC(h.Ue(),p,d))/2),r.AreaXZ[o]=Math.abs(x.kC(h.Ue(),g,g)[2]/2+x.kC(h.Ue(),P,g)[2]/2);let v=h.$X(h.Ue(),c,s),S=h.al(v[0],0,v[2]);r.Inclination[o]=1e-5>h.Zh(v)?0:Math.acos(h.AK(v,S)/(h.Zh(v)*h.Zh(S))),r.Latitude[o]=47*Math.PI/180;let w=x.al(m[0],m[2]),y=x.al(0,-1),b=x.AK(w,y),T=w[0]*y[1]-w[1]*y[0];r.Aspect[o]=Math.atan2(T,b),r.Aspect[o]=normalizeAngle360(r.Aspect[o]);let C=0;if(r.Altitude[o]/100>3300){let e=r.Area[o]/1e4;i=Math.max((C=(2.5+r.Altitude[o]/100*.001)*e)/e,i)}r.SnowWaterEquivalent[o]=C}let o=t-1,s=a-1;for(let e=0;e<s;e++)for(let t=0;t<o;t++){let a=e*o+t,n=Array(8);if(n[0]=getCellIndex(t,e-1,o,s),n[1]=getCellIndex(t+1,e-1,o,s),n[2]=getCellIndex(t+1,e,o,s),n[3]=getCellIndex(t+1,e+1,o,s),n[4]=getCellIndex(t,e+1,o,s),n[5]=getCellIndex(t-1,e+1,o,s),n[6]=getCellIndex(t-1,e,o,s),n[7]=getCellIndex(t-1,e-1,o,s),-1==n[0]||-1==n[1]||-1==n[2]||-1==n[3]||-1==n[4]||-1==n[5]||-1==n[6]||-1==n[7]){r.Curvature[a]=-.0005;continue}r.Altitude[n[1]];let i=r.Altitude[n[0]]/100;r.Altitude[n[7]];let l=r.Altitude[n[2]]/100,u=r.Altitude[a]/100,c=r.Altitude[n[6]]/100;r.Altitude[n[3]];let m=r.Altitude[n[4]]/100;r.Altitude[n[5]];let f=r.P1[a][0]-r.P0[a][0],d=((l+c)/2-u)/(f*f),p=((i+m)/2-u)/(f*f);r.Curvature[a]=2*(d+p)}return r}async function generateSquareMesh(){return{positions:[[1,0,1],[1,0,-1],[-1,0,-1],[1,0,1],[-1,0,-1],[-1,0,1]],normals:[[1],[1],[1],[0],[0],[0]],uvs:[[1,0],[1,1],[0,1],[1,0],[0,1],[0,0]]}}async function getSquareMesh(){return await generateSquareMesh()}let CameraBase=class CameraBase{get matrix(){return this.matrix_}set matrix(e){n._E.copy(e,this.matrix_)}get view(){return this.view_}set view(e){n._E.copy(e,this.view_)}get right(){return this.right_}set right(e){n.R3.copy(e,this.right_)}get up(){return this.up_}set up(e){n.R3.copy(e,this.up_)}get back(){return this.back_}set back(e){n.R3.copy(e,this.back_)}get position(){return this.position_}set position(e){n.R3.copy(e,this.position_)}constructor(){this.matrix_=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.view_=n._E.create(),this.right_=new Float32Array(this.matrix_.buffer,0,4),this.up_=new Float32Array(this.matrix_.buffer,16,4),this.back_=new Float32Array(this.matrix_.buffer,32,4),this.position_=new Float32Array(this.matrix_.buffer,48,4)}};let WASDCamera=class WASDCamera extends CameraBase{get velocity(){return this.velocity_}set velocity(e){n.R3.copy(e,this.velocity_)}get matrix(){return super.matrix}set matrix(e){super.matrix=e,this.recalculateAngles(this.back)}update(e,t){var a,r,i,o;let sign=(e,t)=>(e?1:0)-(t?1:0);this.yaw-=t.analog.x*e*this.rotationSpeed,this.pitch-=t.analog.y*e*this.rotationSpeed,this.yaw=(a=this.yaw)-Math.floor(Math.abs(a)/(r=2*Math.PI))*r*Math.sign(a),this.pitch=Math.min(Math.max(this.pitch,-Math.PI/2),Math.PI/2);let s=n.R3.copy(this.position);super.matrix=n._E.rotateX(n._E.rotationY(this.yaw),this.pitch);let l=t.digital,u=sign(l.right,l.left),c=sign(l.up,l.down),m=n.R3.create(),f=sign(l.backward,l.forward);return n.R3.addScaled(m,this.right,u,m),n.R3.addScaled(m,this.up,c,m),n.R3.addScaled(m,this.back,f,m),n.R3.normalize(m,m),n.R3.mulScalar(m,this.movementSpeed,m),this.velocity=(i=this.velocity,o=Math.pow(1-this.frictionCoefficient,e),n.R3.addScaled(m,n.R3.sub(i,m),o)),this.position=n.R3.addScaled(s,this.velocity,e),this.view=n._E.invert(this.matrix),this.view}recalculateAngles(e){this.yaw=Math.atan2(e[0],e[2]),this.pitch=-Math.asin(e[1])}constructor(e){if(super(),this.pitch=0,this.yaw=0,this.velocity_=n.R3.create(),this.movementSpeed=150,this.rotationSpeed=1,this.frictionCoefficient=.99,e&&(e.position||e.target)){var t,a;let r=null!==(t=e.position)&&void 0!==t?t:n.R3.create(0,0,-5),i=null!==(a=e.target)&&void 0!==a?a:n.R3.create(0,0,0),o=n.R3.normalize(n.R3.sub(r,i));this.recalculateAngles(o),this.position=r}}};var v=a(7048);let S={p_ww:.75,p_wd:.4,p_i_w:.6},w=(0,v.hA)(),y=a(7686),b=-1,T="",getWeatherData=(e,t,a)=>{if(""===T)var n=Math.random()<S.p_i_w?"wet":"dry";else var n=T;let r=[];for(let e=0;e<t-1;e++){r[e]=[];for(let t=0;t<a-1;t++){let a=1+w(.01*e,.01*t);r[e][t]=a}}let i={temperature:[],precipitation:[]},o=[];for(let n=0;n<t;n++){o[n]=[];for(let t=0;t<a;t++){let a=(0,v.hA)(new y(e)),r=Math.max(.9*(1+a(.01*n,.01*t))+.2,0);o[n][t]=r}}for(let s=0;s<t-1;s++)for(let t=0;t<a-1;t++){let l=0;if("wet"===n){let e=2.5*Math.exp(2.5*Math.random())/24;l=e*o[s][t]}let u=-(9*Math.cos(2*Math.floor(e/1e3%365)*Math.PI/365))+(Math.random()-.5),c="wet"===n?-8:0,m=10+u+c+r[s][t];i.temperature[s*a+t]=m,i.precipitation[s*a+t]=l}return T="wet"===n?Math.random()<S.p_ww?"wet":"dry":"dry"===n&&Math.random()<S.p_wd?"wet":"dry",i};var C="src/sample/snowAccumulation/main.ts";let A={position:n.R3.create(-70,350,-80),target:n.R3.create(-800,400,-1e3)};function setCamera(e,t){let a=void 0!==e?e:A.position,n=void 0!==t?t:A.target;return new WASDCamera({position:a,target:n})}function resetTerrainBufferMapping(e,t,a){e.queue.writeBuffer(a,0,t.buffer,t.byteOffset,t.byteLength)}function getCellArray(e){let t=new Float32Array(48*e.Size/4);for(let a=0;a<e.Size;a++)t.set([e.Aspect[a],e.Inclination[a],e.Altitude[a],e.Latitude[a],e.Area[a],e.AreaXZ[a],e.SnowWaterEquivalent[a],e.InterpolatedSWE[a],e.SnowAlbedo[a],e.DaysSinceLastSnowfall[a],e.Curvature[a],0],12*a);return t}let init=async e=>{let{canvas:t,pageState:a,gui:r,stats:i}=e,o=await navigator.gpu.requestAdapter(),s=await o.requestDevice();if(!a.active)return;let l=t.getContext("webgpu");i.showPanel(0);let u=function(e,t){let a={forward:!1,backward:!1,left:!1,right:!1,up:!1,down:!1},n={x:0,y:0,zoom:0},r=!1,setDigital=(e,t)=>{switch(e.code){case"KeyW":a.forward=t,e.preventDefault(),e.stopPropagation();break;case"KeyS":a.backward=t,e.preventDefault(),e.stopPropagation();break;case"KeyA":a.left=t,e.preventDefault(),e.stopPropagation();break;case"KeyD":a.right=t,e.preventDefault(),e.stopPropagation();break;case"Space":a.up=t,e.preventDefault(),e.stopPropagation();break;case"ShiftLeft":case"ControlLeft":case"KeyC":a.down=t,e.preventDefault(),e.stopPropagation()}};return e.addEventListener("keydown",e=>setDigital(e,!0)),e.addEventListener("keyup",e=>setDigital(e,!1)),t.style.touchAction="pinch-zoom",t.addEventListener("pointerdown",()=>{r=!0}),t.addEventListener("pointerup",()=>{r=!1}),t.addEventListener("pointermove",e=>{(r="mouse"!=e.pointerType||(1&e.buttons)!=0)&&(n.x+=e.movementX,n.y+=e.movementY)}),t.addEventListener("wheel",e=>{(r=(1&e.buttons)!=0)&&(n.zoom+=Math.sign(e.deltaY),e.preventDefault(),e.stopPropagation())},{passive:!1}),()=>{let e={digital:a,analog:{x:n.x,y:n.y,zoom:n.zoom,touching:r}};return n.x=0,n.y=0,n.zoom=0,e}}(window,t),c=setCamera(),m={k2Terrain:{name:"K2",terrainFilename:"../assets/img/file/k2-h.tif",textureFilename:"../assets/img/file/k2-t.png",configurationParams:{posNormalizeFactor:5e6,posMax:150,colorMaxScaleFactor:.64,areaScaleFactor:100,r_i_tScaleFactor:.82,k_mScaleFactor:2.5,meltFactor:5.5,maxSWE:6e5,temperatureLapseNormalizeFactor:20,precipitationLapseNormalizeFactor:20,heightMul:.104,gridSize:.7,terrainSkip:3,terrainDataNormalizeFactor:10,defaultTemperature:8},cameraDefaults:{position:n.R3.create(-70,350,-80),target:n.R3.create(-800,400,-1e3)}},everestTerrain:{name:"Everest",terrainFilename:"../assets/img/file/everest.tif",textureFilename:"../assets/img/file/rock.png",configurationParams:{posNormalizeFactor:5e6,posMax:175,colorMaxScaleFactor:.7,areaScaleFactor:500,r_i_tScaleFactor:.78,k_mScaleFactor:2.5,meltFactor:5.5,maxSWE:2e6,temperatureLapseNormalizeFactor:7,precipitationLapseNormalizeFactor:7.5,heightMul:.07,gridSize:4.57,terrainSkip:1,terrainDataNormalizeFactor:100,defaultTemperature:-1.7},cameraDefaults:{position:n.R3.create(-350,615,-380),target:n.R3.create(-70,550,-80)}}},p={terrain:m.k2Terrain},h={resetCamera(){c=setCamera(p.terrain.cameraDefaults.position,p.terrain.cameraDefaults.target)}},x={guiTemperature:p.terrain.configurationParams.defaultTemperature,guiPrecipitation:0,useGuiWeather:!0},P={showStats:!0,showMemoryUsage:!1},v={measurementAltitude:0,tSnowA:0,tSnowB:2,tMeltA:-5,tMeltB:-2,k_e:.2,k_m:p.terrain.configurationParams.k_mScaleFactor,meltFactor:p.terrain.configurationParams.meltFactor,timesteps:0,currentSimulationStep:0,hourOfDay:12,dayOfYear:251},S={heightMul:p.terrain.configurationParams.heightMul,gridSize:p.terrain.configurationParams.gridSize},w={fogStartDist:30,fogEndDist:1200};var y=r.addFolder("Reset");y.open(),y.add(h,"resetCamera").name("Reset Camera");var b=r.addFolder("Terrain");b.open();var T=r.addFolder("Weather");T.open();let C=T.add(x,"guiTemperature",-10,30).name("Temperature"),A=T.add(x,"guiPrecipitation",0,1.5).name("Precipitation").step(.01);T.add(x,"useGuiWeather").name("Use Gui Weather");var F=r.addFolder("Stats");F.add(P,"showStats").name("Show Stats"),F.add(P,"showMemoryUsage").name("Memory Usage");var M=r.addFolder("Simulation Constants");M.add(v,"measurementAltitude",0,1e4).name("Measurement Altitude"),M.add(v,"tSnowA",-5,5).name("Temp Snow A").step(.5),M.add(v,"tSnowB",-5,5).name("Temp Snow B").step(.5),M.add(v,"tMeltA",-10,5).name("Temp Melt A").step(.5),M.add(v,"tMeltB",-10,5).name("Temp Melt B").step(.5),M.add(v,"k_e",0,1).name("k_e").step(.1),M.add(v,"k_m",0,10).name("k_m").step(.5),M.add(v,"meltFactor",0,10).name("Melt Factor").step(.1),M.add(v,"timesteps",0,100).name("Timesteps").step(1),M.add(v,"currentSimulationStep",0,100).name("Curr Step").step(1),M.add(v,"hourOfDay",0,24).name("Hour of Day").step(.5),M.add(v,"dayOfYear",0,365).name("Day of Year").step(1);var _=r.addFolder("Size");_.open(),_.add(S,"heightMul",0,.2).name("Height Multiplier").step(.002),_.add(S,"gridSize",0,10).name("Grid Size").step(.01);var B=r.addFolder("Fog");B.open(),B.add(w,"fogStartDist",10,100).name("Fog Start"),B.add(w,"fogEndDist",1e3,5e3).name("Fog End");let D=window.devicePixelRatio;t.width=t.clientWidth*D,t.height=t.clientHeight*D;let E=navigator.gpu.getPreferredCanvasFormat(),U=await createSkyboxPipeline(s,E),z=s.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(z.getMappedRange()).set(f),z.unmap();let R=s.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),G=await loadCubemapTexture(s),L=s.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}),k=s.createBindGroup({layout:U.getBindGroupLayout(0),label:"skybox group",entries:[{binding:0,resource:{buffer:R,size:64}},{binding:1,resource:L},{binding:2,resource:G.createView({dimension:"cube"})}]});l.configure({device:s,format:E,alphaMode:"premultiplied"});let V=await getTerrainMesh(p.terrain.terrainFilename,p.terrain.configurationParams.terrainSkip,p.terrain.configurationParams.terrainDataNormalizeFactor),I=await getSquareMesh(),N=await getTerrainCells(V);async function setCellBuffer(e){let t=s.createBuffer({size:48*e.Size,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});{let a=new Float32Array(t.getMappedRange());for(let t=0;t<e.Size;t++)a.set([e.Aspect[t],e.Inclination[t],e.Altitude[t],e.Latitude[t],e.Area[t],e.AreaXZ[t],e.SnowWaterEquivalent[t],e.InterpolatedSWE[t],e.SnowAlbedo[t],e.DaysSinceLastSnowfall[t],e.Curvature[t],0],12*t);t.unmap()}return t}let O=await setCellBuffer(N),W=getCellArray(N);h.resetSimulation=function(){x.guiPrecipitation=0,x.guiTemperature=p.terrain.configurationParams.defaultTemperature,A.updateDisplay(),C.updateDisplay(),resetTerrainBufferMapping(s,W,O)},y.add(h,"resetSimulation").name("Reset Simulation");let q=s.createBuffer({size:16,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),Y=s.createBuffer({label:"vertex buffer",size:6*I.positions.length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});{let e=new Float32Array(Y.getMappedRange());for(let t=0;t<I.positions.length;++t)e.set(I.positions[t],6*t),e.set(I.normals[t],6*t+3),e.set(I.uvs[t],6*t+4);Y.unmap()}let j=[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:2,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]}],H=s.createRenderPipeline({layout:"auto",vertex:{module:s.createShaderModule({code:d}),entryPoint:"vs_main",buffers:j},fragment:{module:s.createShaderModule({code:d}),entryPoint:"fs_main",targets:[{format:E}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),X=s.createTexture({size:[t.width,t.height],format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT}),Z=s.createTexture({size:[V.width-1,V.height-1,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),K=s.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});async function setColorTexture(e){let t=await fetch(e),a=await createImageBitmap(await t.blob());return{texture:s.createTexture({size:[a.width,a.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),image:a}}async function setHeightTexture(e){let t=await getHeightData(e);return{texture:s.createTexture({size:[g[0],g[1],1],format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),data:t}}let $=await setColorTexture(p.terrain.textureFilename);s.queue.copyExternalImageToTexture({source:$.image},{texture:$.texture},[$.image.width,$.image.height]);let J=await setHeightTexture(p.terrain.terrainFilename);s.queue.writeTexture({texture:J.texture},J.data,{bytesPerRow:4*g[0]},{width:g[0],height:g[1]});let Q=!1,ee=!1;b.add(p,"terrain",Object.values(m).map(e=>e.name)).name("Select Terrain").setValue(m.k2Terrain.name).onChange(async function(e){var t;p.terrain=Object.values(m).find(t=>t.name===e),V=await getTerrainMesh(p.terrain.terrainFilename,p.terrain.configurationParams.terrainSkip,p.terrain.configurationParams.terrainDataNormalizeFactor),N=await getTerrainCells(V),J=await setHeightTexture(p.terrain.terrainFilename),$=await setColorTexture(p.terrain.textureFilename),W=getCellArray(N),O=await setCellBuffer(N),t=V,Z=s.createTexture({size:[t.width-1,t.height-1,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),S.heightMul=p.terrain.configurationParams.heightMul,S.gridSize=p.terrain.configurationParams.gridSize,_.updateDisplay(),v.k_m=p.terrain.configurationParams.k_mScaleFactor,v.meltFactor=p.terrain.configurationParams.meltFactor,M.updateDisplay(),x.guiTemperature=p.terrain.configurationParams.defaultTemperature,T.updateDisplay(),h.resetSimulation(),c=setCamera(p.terrain.cameraDefaults.position,p.terrain.cameraDefaults.target),ee=!0,Q=!0}),p.terrain=m.k2Terrain;let et=new Float32Array([.1,.1]),ea=s.createBuffer({label:"Grid Uniforms",size:et.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(ea,0,et);let en=s.createBindGroup({layout:H.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:K}},{binding:1,resource:Z.createView()},{binding:2,resource:$.texture.createView()},{binding:3,resource:{buffer:ea}},{binding:4,resource:J.texture.createView()},{binding:5,resource:{buffer:q}}]}),er={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:X.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},ei=s.createBuffer({size:96,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),eo=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:d}),entryPoint:"simulate"}}),es=s.createBindGroup({layout:eo.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:ei}},{binding:1,resource:{buffer:O,offset:0,size:48*N.Size}},{binding:2,resource:$.texture.createView()},{binding:3,resource:Z.createView({format:"rgba32float",dimension:"2d"})},{binding:4,resource:{buffer:q}}]}),el=t.width/t.height,eu=n._E.perspective(2*Math.PI/5,el,1,100),ec=n._E.create(),em=n._E.create(),ef=n._E.perspective(2*Math.PI/5,el,1,15e3),ed=n._E.create(),ep=Date.now(),eg=Date.now(),eh=getWeatherData(ep,2,2);requestAnimationFrame(function frame(){if(!a.active)return;let e=Date.now(),t=(e-ep)/1e3,r=e-eg;ep=e,P.showStats?P.showMemoryUsage?i.showPanel(2):i.showPanel(0):i.showPanel(3);let o=c.update(t,u()),m=n._E.clone(o);m[12]=0,m[13]=0,m[14]=0,Math.floor(r/1e3)>=1&&!x.useGuiWeather&&(eg=e,eh=getWeatherData(e,V.width,V.height)),Q&&(s.queue.writeTexture({texture:J.texture},J.data,{bytesPerRow:4*g[0]},{width:g[0],height:g[1]}),en=s.createBindGroup({layout:H.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:K}},{binding:1,resource:Z.createView()},{binding:2,resource:$.texture.createView()},{binding:3,resource:{buffer:ea}},{binding:4,resource:J.texture.createView()},{binding:5,resource:{buffer:q}}]}),es=s.createBindGroup({layout:eo.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:ei}},{binding:1,resource:{buffer:O,offset:0,size:48*N.Size}},{binding:2,resource:$.texture.createView()},{binding:3,resource:Z.createView({format:"rgba32float",dimension:"2d"})},{binding:4,resource:{buffer:q}}]}),resetTerrainBufferMapping(s,W,O),Q=!1),ee&&(s.queue.copyExternalImageToTexture({source:$.image},{texture:$.texture},[$.image.width,$.image.height]),en=s.createBindGroup({layout:H.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:K}},{binding:1,resource:Z.createView()},{binding:2,resource:$.texture.createView()},{binding:3,resource:{buffer:ea}},{binding:4,resource:J.texture.createView()},{binding:5,resource:{buffer:q}}]}),ee=!1),s.queue.writeBuffer(ei,0,new Float32Array([N.MinAltitude,v.tSnowA,v.tSnowB,v.tMeltA,v.tMeltB,v.k_e,v.k_m,v.meltFactor,v.timesteps,v.currentSimulationStep,v.hourOfDay,v.dayOfYear,p.terrain.configurationParams.posNormalizeFactor,p.terrain.configurationParams.posMax,p.terrain.configurationParams.colorMaxScaleFactor,p.terrain.configurationParams.areaScaleFactor,p.terrain.configurationParams.r_i_tScaleFactor,p.terrain.configurationParams.maxSWE,p.terrain.configurationParams.temperatureLapseNormalizeFactor,p.terrain.configurationParams.precipitationLapseNormalizeFactor,x.useGuiWeather?x.guiTemperature:eh.temperature[0],x.useGuiWeather?x.guiPrecipitation:eh.precipitation[0],0,0])),n._E.identity(ec),n._E.translate(ec,n.R3.fromValues(0,0,-3),ec),n._E.rotateX(ec,-.2*Math.PI,ec),n._E.multiply(eu,ec,em);let f=function(e){let t=c.update(e,u());return n._E.multiply(ef,t,ed),ed}(t);s.queue.writeBuffer(K,0,f.buffer,f.byteOffset,f.byteLength),s.queue.writeBuffer(K,64,new Float32Array([c.position[0],c.position[1],c.position[2],w.fogStartDist,ec[5],ec[9],w.fogEndDist,S.heightMul,p.terrain.configurationParams.posNormalizeFactor,p.terrain.configurationParams.posMax,p.terrain.configurationParams.colorMaxScaleFactor,p.terrain.configurationParams.areaScaleFactor,p.terrain.configurationParams.r_i_tScaleFactor,p.terrain.configurationParams.maxSWE,p.terrain.configurationParams.temperatureLapseNormalizeFactor,p.terrain.configurationParams.precipitationLapseNormalizeFactor])),s.queue.writeBuffer(ea,0,new Float32Array([S.gridSize,S.gridSize]));let d=new Uint32Array([0,0,0,0]);s.queue.writeBuffer(q,0,d.buffer,d.byteOffset,d.byteLength);let h=l.getCurrentTexture();er.colorAttachments[0].view=h.createView(),P.showStats&&i.begin();let y=s.createCommandEncoder();{let e=y.beginComputePass();e.setPipeline(eo),e.setBindGroup(0,es),e.dispatchWorkgroups(Math.ceil((V.width-1)/8),Math.ceil((V.height-1)/8)),e.end()}{let e=y.beginRenderPass(er);e.setPipeline(H),e.setBindGroup(0,en),e.setVertexBuffer(0,Y),e.draw(6,(J.texture.width-1)*(J.texture.height-1)),renderSkybox(s,U,z,R,k,e,f),e.end()}s.queue.submit([y.finish()]),requestAnimationFrame(frame),P.showStats&&i.end()})};var main=()=>makeSample({name:"snowAccmulation",description:"This is real-time snow accumulation on terrein based on real data",gui:!0,stats:!0,init,sources:[{name:C.substring(28),contents:"import { mat4, vec3 } from 'wgpu-matrix';\nimport { makeSample, SampleInit } from '../../components/SampleLayout';\nimport { renderSkybox } from './skyboxPipeline';\nimport { cubeVertexArray, cubeVertexSize, cubeUVOffset, cubePositionOffset, cubeVertexCount } from '../../meshes/cube';\nimport { createSkyboxPipeline, loadCubemapTexture } from './skyboxPipeline';\nimport snowComputeWGSL from './snowCompute.wgsl';\nimport { getTerrainMesh, getTerrainCells } from '../../meshes/terrain';\nimport { getSquareMesh} from '../../meshes/square';\nimport { WASDCamera, cameraSourceInfo } from './camera';\nimport { createInputHandler, inputSourceInfo } from './input';\nimport { getWeatherData } from './weather';\nimport { getDayOfYear, getHourOfDay,degreesToRadians, timeToDays, timeToHours, getNumHoursPassed, getNumDaysPassed, getMin} from '../../meshes/utils';\nimport { getHeightData, numberArray } from '../../meshes/geotiff-utils';\n\nconst cellInstanceByteSize =\n  11 * 4 + // data\n  1 * 4 + // padding\n  0;\n\nconst cameraDefaults = {\n  position: vec3.create(-70, 350, -80),\n  target: vec3.create(-800, 400, -1000),\n};\n\n\nfunction setCamera(position?, target?)\n{\n  const initialCameraPosition = typeof position !== 'undefined' ? position : cameraDefaults.position;\n  const initialCameraTarget = typeof target !== 'undefined' ? target : cameraDefaults.target;\n  return new WASDCamera({ position: initialCameraPosition, target: initialCameraTarget });\n}\n\nfunction resetTerrainBufferMapping(device, cellArray, cellBuffer)\n{\n  device.queue.writeBuffer(\n    cellBuffer,\n    0,\n    cellArray.buffer,\n    cellArray.byteOffset,\n    cellArray.byteLength\n  );\n}\n\n  \nfunction getCellArray(terrainCells)\n{\n  const cellArray = new Float32Array(terrainCells.Size * cellInstanceByteSize / 4);\n  for (let i = 0; i < terrainCells.Size; i++){\n    cellArray.set([\n      terrainCells.Aspect[i],\n      terrainCells.Inclination[i],\n      terrainCells.Altitude[i],\n      terrainCells.Latitude[i],\n      terrainCells.Area[i],\n      terrainCells.AreaXZ[i],\n      terrainCells.SnowWaterEquivalent[i],\n      terrainCells.InterpolatedSWE[i],\n      terrainCells.SnowAlbedo[i],\n      terrainCells.DaysSinceLastSnowfall[i],\n      terrainCells.Curvature[i],\n      0.0,\n    ],i*12);\n  }\n  return cellArray;\n}\n\nconst init: SampleInit = async ({ canvas, pageState, gui, stats }) => {\n \n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n\n  if (!pageState.active) return;\n  const context = canvas.getContext('webgpu') as GPUCanvasContext;\n  stats.showPanel(0);\n \n  // The input handler\n  const inputHandler = createInputHandler(window, canvas);\n\n  // Camera initialization\n  let camera = setCamera();\n  let guiPrecipitation = 0.0;\n\n\n\n  const terrainOptions = {\n    k2Terrain: {\n      name: \"K2\",\n      terrainFilename: \"../assets/img/file/k2-h.tif\",\n      textureFilename: \"../assets/img/file/k2-t.png\",\n      configurationParams: {\n        posNormalizeFactor: 5000000.0, //done\n        posMax: 150.0, //done\n        colorMaxScaleFactor: 0.64, //done\n        areaScaleFactor: 100.0, //done\n        r_i_tScaleFactor: 0.82, //done\n        k_mScaleFactor: 2.5, //done\n        meltFactor: 5.5, //done\n        maxSWE: 600000.0, //done\n        temperatureLapseNormalizeFactor: 20.0, //done\n        precipitationLapseNormalizeFactor: 20.0, //done\n        heightMul: 0.104, //done\n        gridSize: 0.7, //done\n        terrainSkip: 3, //done\n        terrainDataNormalizeFactor: 10.0, //done\n        defaultTemperature: 8.0, //done\n      },\n      cameraDefaults: {\n        position: vec3.create(-70, 350, -80),\n        target: vec3.create(-800, 400, -1000),\n      }\n    },\n    everestTerrain: {\n      name: \"Everest\",\n      terrainFilename: \"../assets/img/file/everest.tif\",\n      textureFilename: \"../assets/img/file/rock.png\",\n      configurationParams: {\n        posNormalizeFactor: 5000000.0,\n        posMax: 175.0,\n        colorMaxScaleFactor: 0.70,\n        areaScaleFactor: 500.0,\n        r_i_tScaleFactor: 0.78,\n        k_mScaleFactor: 2.5,\n        meltFactor: 5.5,\n        maxSWE: 2000000.0,\n        temperatureLapseNormalizeFactor: 7.0,\n        precipitationLapseNormalizeFactor: 7.5,\n        heightMul: 0.07, \n        gridSize: 4.57, \n        terrainSkip: 1.0,\n        terrainDataNormalizeFactor: 100.0,\n        defaultTemperature: -1.7,\n      },\n      cameraDefaults: {\n        position: vec3.create(-350, 615, -380),\n        target: vec3.create(-70, 550, -80),\n      }\n    },\n  };\n\n  const terrainParams = {\n    terrain: terrainOptions.k2Terrain,\n  }\n\n  const resetParams: any = \n  {\n    resetCamera() {\n      camera = setCamera(terrainParams.terrain.cameraDefaults.position, terrainParams.terrain.cameraDefaults.target);\n    },\n  };\n\n  const weatherParams = \n  {\n    guiTemperature: terrainParams.terrain.configurationParams.defaultTemperature,\n    guiPrecipitation: guiPrecipitation,\n    useGuiWeather: true,\n  }\n\n  const statsParams =\n  {\n    showStats: true,\n    showMemoryUsage: false,\n  }\n\n  const constantsParams = \n  {\n    measurementAltitude: 0.0,\n    tSnowA: 0.0,\n    tSnowB: 2.0,\n    tMeltA: -5.0,\n    tMeltB: -2.0,\n    k_e: 0.2,\n    k_m: terrainParams.terrain.configurationParams.k_mScaleFactor,\n    meltFactor: terrainParams.terrain.configurationParams.meltFactor,\n    timesteps: 0.0,\n    currentSimulationStep: 0.0,\n    hourOfDay: 12.0,\n    dayOfYear: 251.0, \n  }\n\n  const sizeParams = \n  {\n    heightMul: terrainParams.terrain.configurationParams.heightMul,\n    gridSize: terrainParams.terrain.configurationParams.gridSize,\n  }\n\n  const fogParams = \n  {\n    fogStartDist: 30.0,\n    fogEndDist: 1200.0,\n  }\n\n  var resetFolder = gui.addFolder('Reset');\n  resetFolder.open();\n  resetFolder.add(resetParams, 'resetCamera').name(\"Reset Camera\");\n\n  var terrainFolder = gui.addFolder('Terrain');\n  terrainFolder.open();\n\n  var weatherFolder = gui.addFolder('Weather');\n  weatherFolder.open();\n  let temperatureController = weatherFolder.add(weatherParams, 'guiTemperature', -10.0, 30.0).name(\"Temperature\");\n  let precipController = weatherFolder.add(weatherParams, 'guiPrecipitation', 0.0, 1.5).name(\"Precipitation\").step(0.01);\n  weatherFolder.add(weatherParams, 'useGuiWeather').name(\"Use Gui Weather\");\n\n  var statsFolder = gui.addFolder('Stats');\n  // statsFolder.open();\n  statsFolder.add(statsParams, 'showStats').name(\"Show Stats\");\n  statsFolder.add(statsParams, 'showMemoryUsage').name(\"Memory Usage\");\n\n  var constantsFolder = gui.addFolder('Simulation Constants');\n  // constantsFolder.open();\n  constantsFolder.add(constantsParams, 'measurementAltitude', 0.0, 10000.0).name(\"Measurement Altitude\");\n  constantsFolder.add(constantsParams, 'tSnowA', -5.0, 5.0).name(\"Temp Snow A\").step(0.5);\n  constantsFolder.add(constantsParams, 'tSnowB', -5.0, 5.0).name(\"Temp Snow B\").step(0.5);\n  constantsFolder.add(constantsParams, 'tMeltA', -10.0, 5.0).name(\"Temp Melt A\").step(0.5);\n  constantsFolder.add(constantsParams, 'tMeltB', -10.0, 5.0).name(\"Temp Melt B\").step(0.5);\n  constantsFolder.add(constantsParams, 'k_e', 0.0, 1.0).name(\"k_e\").step(0.1);\n  constantsFolder.add(constantsParams, 'k_m', 0.0, 10.0).name(\"k_m\").step(0.5);\n  constantsFolder.add(constantsParams, 'meltFactor', 0.0, 10.0).name(\"Melt Factor\").step(0.1);\n  constantsFolder.add(constantsParams, 'timesteps', 0.0, 100.0).name(\"Timesteps\").step(1.0);\n  constantsFolder.add(constantsParams, 'currentSimulationStep', 0.0, 100.0).name(\"Curr Step\").step(1.0);\n  constantsFolder.add(constantsParams, 'hourOfDay', 0.0, 24.0).name(\"Hour of Day\").step(0.5);\n  constantsFolder.add(constantsParams, 'dayOfYear', 0.0, 365.0).name(\"Day of Year\").step(1.0);\n\n  var sizeFolder = gui.addFolder('Size');\n  sizeFolder.open();\n  sizeFolder.add(sizeParams, 'heightMul', 0.0, 0.2).name(\"Height Multiplier\").step(0.002);\n  sizeFolder.add(sizeParams, 'gridSize', 0.0, 10.0).name(\"Grid Size\").step(0.01);\n \n  var fogFolder = gui.addFolder('Fog');\n  fogFolder.open();\n  fogFolder.add(fogParams, 'fogStartDist', 10.0, 100.0).name(\"Fog Start\");\n  fogFolder.add(fogParams, 'fogEndDist', 1000.0, 5000.0).name(\"Fog End\"); \n\n  const devicePixelRatio = window.devicePixelRatio;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\n  // Initialize the skybox pipeline\n  const skyboxPipeline = await createSkyboxPipeline(device, presentationFormat);\n\n  // Initialize the vertex buffer for the skybox\n  const skyboxVerticesBuffer = device.createBuffer({\n    size: cubeVertexArray.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  new Float32Array(skyboxVerticesBuffer.getMappedRange()).set(cubeVertexArray);\n  skyboxVerticesBuffer.unmap();\n  // Initialize the uniform buffer for the skybox\n  const skyboxUniformBuffer = device.createBuffer({\n    size: 16 * 4,  // Size for 2 4x4 matrices (view and projection)\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  // Load the cubemap texture for the skybox\n  const cubemapTexture = await loadCubemapTexture(device);\n\n  // Create a sampler for the cubemap texture\n  const cubemapSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear',\n    mipmapFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge',\n    addressModeW: 'clamp-to-edge',\n  });\n\n  // Initialize the uniform bind group for the skybox\n  const skyboxUniformBindGroup = device.createBindGroup({\n    layout: skyboxPipeline.getBindGroupLayout(0),\n    label: \"skybox group\",\n    entries: [\n      { binding: 0, resource: { buffer: skyboxUniformBuffer,size: 4*16,} },\n      { binding: 1, resource: cubemapSampler },\n      { binding: 2, resource: cubemapTexture.createView({\n        dimension: 'cube',\n      }) },\n    ],\n  });\n\n  context.configure({\n    device,\n    format: presentationFormat,\n    alphaMode: 'premultiplied',\n  });\n\n  let mesh=await getTerrainMesh(terrainParams.terrain.terrainFilename, terrainParams.terrain.configurationParams.terrainSkip, terrainParams.terrain.configurationParams.terrainDataNormalizeFactor);\n  const smesh=await getSquareMesh();\n  let terrainCells = await getTerrainCells(mesh);\n\n  async function setCellBuffer(terrainCells)\n  {\n    let cellBuffer = device.createBuffer({\n      size: terrainCells.Size * cellInstanceByteSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    {\n      const mapping = new Float32Array(cellBuffer.getMappedRange());\n      for (let i = 0; i < terrainCells.Size; i++){\n        mapping.set([\n          terrainCells.Aspect[i],\n          terrainCells.Inclination[i],\n          terrainCells.Altitude[i],\n          terrainCells.Latitude[i],\n          terrainCells.Area[i],\n          terrainCells.AreaXZ[i],\n          terrainCells.SnowWaterEquivalent[i],\n          terrainCells.InterpolatedSWE[i],\n          terrainCells.SnowAlbedo[i],\n          terrainCells.DaysSinceLastSnowfall[i],\n          terrainCells.Curvature[i],\n          0.0,\n        ],i*12);\n      }\n      cellBuffer.unmap();\n    }\n    return cellBuffer;\n  }\n\n  let cellBuffer = await setCellBuffer(terrainCells);\n  let cellArray = getCellArray(terrainCells);\n\n\n  resetParams.resetSimulation = function() {\n    weatherParams.guiPrecipitation = 0.0;\n    weatherParams.guiTemperature = terrainParams.terrain.configurationParams.defaultTemperature;\n    precipController.updateDisplay();\n    temperatureController.updateDisplay();\n    resetTerrainBufferMapping(device, cellArray, cellBuffer);\n  };\n  resetFolder.add(resetParams, 'resetSimulation').name(\"Reset Simulation\");\n\n  const maxBuffer = device.createBuffer({\n    size: 4 * 4,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n  });\n  \n  const vertexBuffer = device.createBuffer({\n    label: \"vertex buffer\",\n    size: smesh.positions.length * 6 * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  \n  {\n    const mapping = new Float32Array(vertexBuffer.getMappedRange());\n    for (let i = 0; i < smesh.positions.length; ++i) {\n      mapping.set(smesh.positions[i], 6 * i);\n      mapping.set(smesh.normals[i], 6 * i + 3);\n      mapping.set(smesh.uvs[i], 6 * i+4);\n    }\n    vertexBuffer.unmap();\n  }\n  const vertexBuffers: Iterable<GPUVertexBufferLayout> = [\n    {\n      arrayStride: Float32Array.BYTES_PER_ELEMENT * 6,\n      attributes: [\n        {\n          // position\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float32x3',\n        },\n        {\n          // normal\n          shaderLocation: 1,\n          offset: Float32Array.BYTES_PER_ELEMENT * 3,\n          format: 'float32',\n        },\n        {\n          // uv\n          shaderLocation: 2,\n          offset: Float32Array.BYTES_PER_ELEMENT * 4,\n          format: 'float32x2',\n        },\n      ],\n    },\n  ];\n\n  const renderPipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module: device.createShaderModule({\n        code: snowComputeWGSL,\n      }),\n      entryPoint: 'vs_main',\n      buffers: vertexBuffers,\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: snowComputeWGSL,\n      }),\n      entryPoint: 'fs_main',\n      targets: [\n        {\n          format: presentationFormat,\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: 'depth24plus-stencil8',\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: [canvas.width, canvas.height],\n    format: 'depth24plus-stencil8',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  let writableTexture = device.createTexture({\n    size: [mesh.width-1, mesh.height-1, 1],\n    format: 'rgba32float', // Adjust based on your requirements\n    usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  const uniformBufferSize =\n    4 * 4 * 4 + // modelViewProjectionMatrix : mat4x4<f32>\n    3 * 4 + // right : vec3<f32>\n    4 + // padding\n    3 * 4 + // up : vec3<f32>\n    4 + // heightMul\n    8 * 4 + //configurationCS\n    0;\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  async function setColorTexture(filename)\n  {\n    const response = await fetch(filename);\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    let cubeTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    return { texture: cubeTexture, image: imageBitmap };\n  }\n\n  async function setHeightTexture(filename)\n  {\n    const heightData = await getHeightData(filename);\n    \n    let heightTextureSet = device.createTexture({\n      size: [numberArray[0], numberArray[1],1],\n      format: \"r32float\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    return { texture: heightTextureSet, data: heightData};\n  }\n\n  function setTerrainTexture(mesh)\n  {\n    writableTexture = device.createTexture({\n      size: [mesh.width-1, mesh.height-1, 1],\n      format: 'rgba32float', // Adjust based on your requirements\n      usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.STORAGE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n  }\n\n  let color = await setColorTexture(terrainParams.terrain.textureFilename);\n  device.queue.copyExternalImageToTexture(\n    { source: color.image },\n    { texture: color.texture },\n    [color.image.width, color.image.height]\n  );\n\n  let height = await setHeightTexture(terrainParams.terrain.terrainFilename);\n  device.queue.writeTexture(\n    { texture: height.texture },\n    height.data,\n    {bytesPerRow:numberArray[0]*4},\n    { width: numberArray[0], height: numberArray[1] }\n  );\n\n  let heightChanged = false;\n  let colorChanged = false;\n  terrainFolder.add(terrainParams, 'terrain',Object.values(terrainOptions).map(option => option.name)).name(\"Select Terrain\")\n  .setValue(terrainOptions.k2Terrain.name)\n  .onChange(async function (value) {\n      terrainParams.terrain = Object.values(terrainOptions).find(option => option.name === value);\n      mesh = await getTerrainMesh(terrainParams.terrain.terrainFilename, terrainParams.terrain.configurationParams.terrainSkip, terrainParams.terrain.configurationParams.terrainDataNormalizeFactor);\n      terrainCells = await getTerrainCells(mesh);\n      height = await setHeightTexture(terrainParams.terrain.terrainFilename);\n      color = await setColorTexture(terrainParams.terrain.textureFilename);\n      cellArray = getCellArray(terrainCells);\n      cellBuffer = await setCellBuffer(terrainCells);\n      setTerrainTexture(mesh);\n\n      sizeParams.heightMul = terrainParams.terrain.configurationParams.heightMul;\n      sizeParams.gridSize = terrainParams.terrain.configurationParams.gridSize;\n      sizeFolder.updateDisplay();\n      constantsParams.k_m = terrainParams.terrain.configurationParams.k_mScaleFactor;\n      constantsParams.meltFactor = terrainParams.terrain.configurationParams.meltFactor;\n      constantsFolder.updateDisplay();\n      weatherParams.guiTemperature = terrainParams.terrain.configurationParams.defaultTemperature;\n      weatherFolder.updateDisplay();\n      resetParams.resetSimulation();\n      camera = setCamera(terrainParams.terrain.cameraDefaults.position, terrainParams.terrain.cameraDefaults.target);\n      colorChanged = true;\n      heightChanged = true;\n    });\n  // Can't get this to be set by default so doing it here\n  terrainParams.terrain = terrainOptions.k2Terrain;\n\n  const uniformArray = new Float32Array([0.1, 0.1]);\n  const gridBuffer = device.createBuffer({\n    label: \"Grid Uniforms\",\n    size: uniformArray.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  device.queue.writeBuffer(gridBuffer, 0, uniformArray);\n  let uniformBindGroup = device.createBindGroup({\n    layout: renderPipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer,\n        },\n      },\n      {\n        binding: 1,\n        resource: writableTexture.createView(),\n      },\n      {\n        binding: 2,\n        resource: color.texture.createView(),\n      },\n      {\n        binding: 3,\n        resource: {\n          buffer: gridBuffer,\n        }\n      },\n      {\n        binding: 4,\n        resource: height.texture.createView(),\n      },\n      {\n        binding: 5,\n        resource: {\n          buffer: maxBuffer,\n        }\n      }\n    ],\n  });\n\n  const renderPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: undefined, // Assigned later\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n      },\n    ],\n    depthStencilAttachment: {\n      view: depthTexture.createView(),\n\n      depthClearValue: 1.0,\n      depthLoadOp: 'clear',\n      depthStoreOp: 'store',\n      stencilClearValue: 0,\n      stencilLoadOp: 'clear',\n      stencilStoreOp: 'store',\n    },\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Simulation compute pipeline\n  //////////////////////////////////////////////////////////////////////////////\n  const simulationParams = {\n    simulate: true,\n    deltaTime: 0.04,\n  };\n\n  const simulationUBOBufferSize =\n    7 * 4 + // simulationCS\n    1 * 4 + // padding\n    4 * 4 + // simulationCSVar\n    8 * 4 + // configurationCS\n    2 * 4 + // weatherData: temp+perci\n    2 * 4 + // padding\n    0;\n  const simulationUBOBuffer = device.createBuffer({\n    size: simulationUBOBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  const computePipeline = device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: device.createShaderModule({\n        code: snowComputeWGSL,\n      }),\n      entryPoint: 'simulate',\n    },\n  });\n  let computeBindGroup = device.createBindGroup({\n    layout: computePipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: simulationUBOBuffer,\n        },\n      },\n      {\n        binding: 1,\n        resource: {\n          buffer: cellBuffer,\n          offset: 0,\n          size: terrainCells.Size * cellInstanceByteSize,\n        },\n      },\n      {\n        binding: 2,\n        resource: color.texture.createView(),\n      },\n      {\n        binding: 3,\n        resource: writableTexture.createView({\n            format: 'rgba32float',\n            dimension: '2d',\n          }\n        ),\n      },\n      {\n        binding: 4,\n        resource: {\n          buffer: maxBuffer,\n        }\n      },\n    ],\n  });\n\n  const aspect = canvas.width / canvas.height;\n  const projection = mat4.perspective((2 * Math.PI) / 5, aspect, 1, 100.0);\n  const view = mat4.create();\n  const mvp = mat4.create();\n\n  const projectionMatrix = mat4.perspective(\n    (2 * Math.PI) / 5,\n    aspect,\n    1,\n    15000.0\n  );\n\n  const modelViewProjectionMatrix = mat4.create();\n\n  function getModelViewProjectionMatrix(deltaTime: number) {\n    const viewMatrix = camera.update(deltaTime, inputHandler());\n    mat4.multiply(projectionMatrix, viewMatrix, modelViewProjectionMatrix);\n    return modelViewProjectionMatrix as Float32Array;\n  }\n\n  let lastFrameMS = Date.now();\n  let lastDayMS = Date.now()\n  let weatherData = getWeatherData(lastFrameMS, 2, 2);\n\n  function frame() {\n    // Sample is no longer the active page.\n    if (!pageState.active) return;\n    const now = Date.now();\n    const deltaTime = (now - lastFrameMS) / 1000;\n    const deltaTimeFull = now - lastDayMS;\n    lastFrameMS = now;\n    if (statsParams.showStats)\n    {\n      if (statsParams.showMemoryUsage)\n      {\n        stats.showPanel(2);\n      }\n      else\n      {\n        stats.showPanel(0);\n      }\n    }\n    else\n    {\n      stats.showPanel(3)\n    }\n\n\n    // Update camera\n    const viewMatrix = camera.update(deltaTime, inputHandler());\n\n    // Render skybox\n    const skyboxViewMatrix = mat4.clone(viewMatrix);\n    skyboxViewMatrix[12] = 0; // Remove translation component\n    skyboxViewMatrix[13] = 0;\n    skyboxViewMatrix[14] = 0;\n\n    if (getNumDaysPassed(deltaTimeFull) >= 1 && !weatherParams.useGuiWeather)\n    {\n      lastDayMS = now;\n      weatherData = getWeatherData(now, mesh.width, mesh.height);\n    }\n\n    if (heightChanged)\n    {\n      device.queue.writeTexture(\n        { texture: height.texture },\n        height.data,\n        {bytesPerRow:numberArray[0]*4},\n        { width: numberArray[0], height: numberArray[1] }\n      );\n      uniformBindGroup = device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: uniformBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: writableTexture.createView(),\n          },\n          {\n            binding: 2,\n            resource: color.texture.createView(),\n          },\n          {\n            binding: 3,\n            resource: {\n              buffer: gridBuffer,\n            }\n          },\n          {\n            binding: 4,\n            resource: height.texture.createView(),\n          },\n          {\n            binding: 5,\n            resource: {\n              buffer: maxBuffer,\n            }\n          }\n        ],\n      });\n      computeBindGroup = device.createBindGroup({\n        layout: computePipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: simulationUBOBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: {\n              buffer: cellBuffer,\n              offset: 0,\n              size: terrainCells.Size * cellInstanceByteSize,\n            },\n          },\n          {\n            binding: 2,\n            resource: color.texture.createView(),\n          },\n          {\n            binding: 3,\n            resource: writableTexture.createView({\n                format: 'rgba32float',\n                dimension: '2d',\n              }\n            ),\n          },\n          {\n            binding: 4,\n            resource: {\n              buffer: maxBuffer,\n            }\n          },\n        ],\n      });\n      resetTerrainBufferMapping(device, cellArray, cellBuffer);\n      heightChanged = false;\n    }\n\n    if (colorChanged)\n    {\n      device.queue.copyExternalImageToTexture(\n        { source: color.image },\n        { texture: color.texture },\n        [color.image.width, color.image.height]\n      );\n      uniformBindGroup = device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: uniformBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: writableTexture.createView(),\n          },\n          {\n            binding: 2,\n            resource: color.texture.createView(),\n          },\n          {\n            binding: 3,\n            resource: {\n              buffer: gridBuffer,\n            }\n          },\n          {\n            binding: 4,\n            resource: height.texture.createView(),\n          },\n          {\n            binding: 5,\n            resource: {\n              buffer: maxBuffer,\n            }\n          }\n        ],\n      });\n      colorChanged = false;\n    }\n\n    device.queue.writeBuffer(\n      simulationUBOBuffer,\n      0,\n      new Float32Array([\n        terrainCells.MinAltitude,\n        constantsParams.tSnowA,\n        constantsParams.tSnowB,\n        constantsParams.tMeltA,\n        constantsParams.tMeltB,\n        constantsParams.k_e,\n        constantsParams.k_m,\n        constantsParams.meltFactor,\n        constantsParams.timesteps,\n        constantsParams.currentSimulationStep,\n        constantsParams.hourOfDay,\n        constantsParams.dayOfYear,\n        terrainParams.terrain.configurationParams.posNormalizeFactor,\n        terrainParams.terrain.configurationParams.posMax,\n        terrainParams.terrain.configurationParams.colorMaxScaleFactor,\n        terrainParams.terrain.configurationParams.areaScaleFactor,\n        terrainParams.terrain.configurationParams.r_i_tScaleFactor,\n        terrainParams.terrain.configurationParams.maxSWE,\n        terrainParams.terrain.configurationParams.temperatureLapseNormalizeFactor,\n        terrainParams.terrain.configurationParams.precipitationLapseNormalizeFactor,\n        weatherParams.useGuiWeather ? weatherParams.guiTemperature : weatherData.temperature[0], //TODO: bind weather Data temperature per frame\n        weatherParams.useGuiWeather ? weatherParams.guiPrecipitation : weatherData.precipitation[0], //TODO: bind weather Data percipitation per frame\n        0.0,\n        0.0,\n      ])\n    );\n\n    // if (now % 1000 > 998)\n    // {\n    //   if (weatherParams.useGuiWeather)\n    //   {\n    //     computeSnowCPU(terrainCells, constantsParams, weatherParams.guiTemperature, weatherParams.guiPrecipitation);\n    //   }\n    //   else\n    //   {\n    //     computeSnowCPU(terrainCells, constantsParams);\n    //   }\n    // }\n\n    mat4.identity(view);\n    mat4.translate(view, vec3.fromValues(0, 0, -3), view);\n    mat4.rotateX(view, Math.PI * -0.2, view);\n    mat4.multiply(projection, view, mvp);\n\n    const cameraViewProj = getModelViewProjectionMatrix(deltaTime);\n    device.queue.writeBuffer(\n      uniformBuffer,\n      0,\n      cameraViewProj.buffer,\n      cameraViewProj.byteOffset,\n      cameraViewProj.byteLength\n    )\n\n    // prettier-ignore\n    device.queue.writeBuffer(\n      uniformBuffer,\n      64,\n      new Float32Array([\n        camera.position[0], camera.position[1], camera.position[2], // right\n        fogParams.fogStartDist, // padding //fogstart\n        view[5], view[9], fogParams.fogEndDist,// up //fogend\n        sizeParams.heightMul, // heightMul\n        terrainParams.terrain.configurationParams.posNormalizeFactor,\n        terrainParams.terrain.configurationParams.posMax,\n        terrainParams.terrain.configurationParams.colorMaxScaleFactor,\n        terrainParams.terrain.configurationParams.areaScaleFactor,\n        terrainParams.terrain.configurationParams.r_i_tScaleFactor,\n        terrainParams.terrain.configurationParams.maxSWE,\n        terrainParams.terrain.configurationParams.temperatureLapseNormalizeFactor,\n        terrainParams.terrain.configurationParams.precipitationLapseNormalizeFactor,\n      ])\n    );\n\n    device.queue.writeBuffer(gridBuffer, 0, new Float32Array([sizeParams.gridSize, sizeParams.gridSize]));\n\n\n    let maxArray = new Uint32Array([0,0,0,0]);\n\n    device.queue.writeBuffer(\n      maxBuffer,\n      0,\n      maxArray.buffer,\n      maxArray.byteOffset,\n      maxArray.byteLength\n    );\n    \n    const swapChainTexture = context.getCurrentTexture();\n    // prettier-ignore\n    renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView();\n    \n    if (statsParams.showStats) {\n      stats.begin();\n    }\n\n      \n    const commandEncoder = device.createCommandEncoder();\n    \n    {\n      const passEncoder = commandEncoder.beginComputePass();\n      passEncoder.setPipeline(computePipeline);\n      passEncoder.setBindGroup(0, computeBindGroup);\n      passEncoder.dispatchWorkgroups(Math.ceil((mesh.width-1) / 8),Math.ceil((mesh.height-1) / 8));\n      passEncoder.end();\n    }\n    {\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setPipeline(renderPipeline);\n      passEncoder.setBindGroup(0, uniformBindGroup);\n      passEncoder.setVertexBuffer(0, vertexBuffer);\n      passEncoder.draw(6,(height.texture.width-1)*(height.texture.height-1));//(heightTexture.width-1)*(heightTexture.height-1)\n      renderSkybox(device, skyboxPipeline, skyboxVerticesBuffer, skyboxUniformBuffer, skyboxUniformBindGroup,passEncoder,cameraViewProj);\n      passEncoder.end();\n    }\n    \n    device.queue.submit([commandEncoder.finish()]);\n\n    requestAnimationFrame(frame);\n    if (statsParams.showStats) {\n      stats.end()\n    }\n  }\n  requestAnimationFrame(frame);\n};\n\nconst Particles: () => JSX.Element = () =>\n  makeSample({\n    name: 'snowAccmulation',\n    description:\n      'This is real-time snow accumulation on terrein based on real data',\n    gui: true,\n    stats: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      {\n        name: './snowCompute.wgsl',\n        contents: snowComputeWGSL,\n        editable: true,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default Particles;"},{name:"./snowCompute.wgsl",contents:d,editable:!0}],filename:C})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5",sourceFileNav:"SampleLayout_sourceFileNav__9Hf73",sourceFileContainer:"SampleLayout_sourceFileContainer__9iti6"}}}]);